# Integrate

## With Backend Web Services

When you start the AuthC server a secret key is generated on `SERVER_KEY_PATH=./keyfile` in the JSON Web Key format.
This key is used to verify that JWT tokens recieved by your web services/backend APIs are verified and trusted.

JWTs are frequently passed from your frontend application to your web service in order to authenticate users into your APIs.

Described below is an example key and how you can use this key proided by AuthC in your web services.

### Generate Key

The example key below is generated by AuthC on first start (or uses an existing keyfile if one is already available). The AuthC Serer uses this key to SIGN JWTs that are made available for your application APIs - you'll be using this key to VERIFY the JWT passed from AuthC to authenticate a user with your APIs.

Both the key on the AuthC server and installed on your web service must match, even if they are hosted on different servers. This requires that your web service references the key produced by AuthC either through an environment variable or file.

```javascript
// example ./keyfile in JWK located in AuthCompanion code directory
{
  "key_ops": [
    "sign",
    "verify"
  ],
  "ext": true,
  "kty": "oct",
  "k": "EClK3wR3GxRM2sIAfZE00IGkpM_HeTVdy_H93_EqDcddonfEMWQpSrtGju_xFC9vGUAzHAcREbUe1XeodmTZ2Q",
  "alg": "HS256"
}
```

### Import Key & Verify Tokens

Next, import the JWK into your web service. One way to do this is by reading a file like below (make a copy of the file generated by AuthC on your server).

```javascript
// ./key.js
//  This function reads a key from a file called "keyfile" and imports it using the Web Cryptography API.
import { readFileSync } from "fs";
import { webcrypto } from "crypto";

const { subtle } = webcrypto;

export async function importKey() {
  try {
    const rawKey = readFileSync("./keyfile");
    const importkey = JSON.parse(rawKey);

    const key = await subtle.importKey(
      "jwk",
      importkey,
      {
        name: "HMAC",
        hash: "SHA-256",
      },
      true,
      ["sign", "verify"]
    );
    return key;
  } catch (error) {
    console.log(error);
  }
}
```

With the key imported, you can use a library like [https://github.com/panva/jose](https://github.com/panva/jose) to both verify incoming JWTs (using the secret key) and access the payload contents to learn more about the user.

```javascript
// jwt.js
import * as jose from "jose";
import { importKey } from "./key.js";

export async function validateJWT(jwt) {
  try {
    // Load the key like below or import the key earlier into memory
    const secretKey = await importKey();

    const { payload } = await jose.jwtVerify(jwt, secretKey);

    return payload;
  } catch (error) {
    throw {
      statusCode: 401,
      message: "Unauthorized, Token Validation Failed.",
    };
  }
}
```

Passing this verification step allows the request to access the API resources - any errors should deny the request to your APIs.

## With Frontend Clients

After a user's successful account registration or login, AuthC will first save the user's JWT in local storage and Refresh token as a cookie, then redirect the user to your frontend application.

Let AuthC know where to redirect a user by setting the config `APPLICATION_ORIGIN=http://localhost:3002/v1/web/home` - this value should typically your web application's home page.

With the access token easily accessible, your web application can now:

- Check if a user is logged in by seeing if the JWT variable is set. If it isn't, redirect the user to the login page.

```javascript
if (!localStorage.getItem("ACCESS_TOKEN")) {
  window.location.href = "http://auth.example.com";
}
```

- Retrieve the token from local storage and add it as a Bearer HTTP `authentication` header when calling backend APIs/services to authenticate the user.

```javascript
const token = localStorage.getItem("ACCESS_TOKEN");

const response = await fetch(yourWebService, {
  method: "POST",
  headers: {
    "Content-type": "application/json",
    Authorization: `Bearer ${token}`, // notice the Bearer + AuthC's access token
  },
  body: JSON.stringify(yourData),
});

const result = await response.json();
console.log(result);
```

- Decode the JWT on the client to access data in the payload - which provides more information about the user.

```javascript
import jwtDecode from "https://cdn.skypack.dev/jwt-decode";

const token = localStorage.getItem("ACCESS_TOKEN");

let decodedClaims = jwtDecode(token);
console.log(decodedClaims);

/* prints:
{
  "userid": "qbnjnj3rduw8bgg7hbtgnici",
  "name": "Authy Person",
  "email": "hello@authcompanion.com",
  "userFingerprint": "$argon2id$v=19$m=64000,t=3,p=1$hLGlPgligsPoP5muWpUEqw$JaR0wRBMDlbN/jBkJbyw/C4GmcScJ3uylQRDjATZNT4",
  "scope": "user",
  "iat": 1688927980,
  "exp": 1688931580
}
 */
```

- Logout a user by simply deleting the token on the client side, so that it can't be used for subsequent API calls.

```javascript
function LogoutUser() {
  localStorage.removeItem("ACCESS_TOKEN");
}
```

### Implement the "Silent Refresh" for JWTs

Silent refresh is a mechanism to generate a new access token using a refresh token automatically. This is true when the access token is expired but refresh token is available and valid.

AuthC has a default expiration of 1 hour for all short lived access tokens; making the Silent Refresh an important implementation step to prevent users from needlessly logging in again.

Implementing the "Silent Refresh" follows three steps:

1. Access your web service resource with the access token set by AuthC
2. if 401 - Unauthorized is returned by server, Get a new access token by using the Refresh token with AuthC's `/auth/refresh` endpoint
3. Retry step 1 using the new access token

```javascript
// Function to call the backend API with the current access token
async function callBackend() {
  // Retrieve the access token from the browser's local storage
  const token = localStorage.getItem("ACCESS_TOKEN");

  // Make an API request to the web service, including the access token
  const response = await fetch("/private/resource", {
    method: "POST",
    headers: {
      "Content-type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(yourRequestData),
  });

  return response;
}

try {
  // Make a normal request to the web service
  const response = await callBackend();

  // Parse the response as JSON
  const webserviceResponse = await response.json();

  // Check if the response is unauthorized (access token expired)
  if (response.status === 401) {
    // Request a new access token from the AuthC refresh endpoint
    const refreshResponse = await fetch(
      "http://127.0.0.1:3002/v1/auth/refresh",
      {
        method: "POST",
        headers: {
          "Content-type": "application/json",
        },
        body: JSON.stringify({}),
      }
    ).then((response) => response.json());

    // Update the access token in the local storage with the new token from AuthC
    localStorage.setItem(
      "ACCESS_TOKEN",
      refreshResponse.data.attributes.access_token
    );

    // Make another request to the web service using the new access token
    const refreshedResponse = await callBackend();
    const refreshedWebserviceResponse = await refreshedResponse.json();

    // Use the refreshedWebserviceResponse as needed
  }
} catch (error) {
  // Catch any errors that occur during the API calls
  console.error(error);
}
```

## Reference Architecture

Roughly, your experience will look something like this:

![landscape](https://raw.githubusercontent.com/authcompanion/authcompanion2/main/.github/public/authcLandscape.png)

## Related Readings

Be sure to familiarize yourself with token-based authentication using JSON Web
Tokens.

- [The Ultimate Guide to handling JWTs on frontend
  clients](https://hasura.io/blog/best-practices-of-using-jwt-with-graphql/)

- [Web Authentication Method Comparison](https://testdriven.io/blog/web-authentication-methods/#token-based-authentication)
